'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlackEventAdapter = exports.errorCodes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _lodash = require('lodash.isstring');

var _lodash2 = _interopRequireDefault(_lodash);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _httpHandler = require('./http-handler');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _debug2.default)('@slack/events-api:adapter');

var errorCodes = exports.errorCodes = {
  BODY_PARSER_NOT_PERMITTED: 'SLACKADAPTER_BODY_PARSER_NOT_PERMITTED_FAILURE'
};

var SlackEventAdapter = exports.SlackEventAdapter = function (_EventEmitter) {
  _inherits(SlackEventAdapter, _EventEmitter);

  function SlackEventAdapter(signingSecret) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SlackEventAdapter);

    if (!(0, _lodash2.default)(signingSecret)) {
      throw new TypeError('SlackEventAdapter needs a signing secret');
    }

    var _this = _possibleConstructorReturn(this, (SlackEventAdapter.__proto__ || Object.getPrototypeOf(SlackEventAdapter)).call(this));

    _this.signingSecret = signingSecret;
    _this.includeBody = !!options.includeBody || false;
    _this.includeHeaders = !!options.includeHeaders || false;
    _this.waitForResponse = !!options.waitForResponse || false;

    debug('adapter instantiated - options: %o', {
      includeBody: _this.includeBody,
      includeHeaders: _this.includeHeaders,
      waitForResponse: _this.waitForResponse
    });
    return _this;
  }

  // TODO: options (like https)


  _createClass(SlackEventAdapter, [{
    key: 'createServer',
    value: function createServer() {
      var _this2 = this;

      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/slack/events';

      // NOTE: this is a workaround for a shortcoming of the System.import() tranform
      return Promise.resolve().then(function () {
        debug('server created - path: %s', path);

        return _http2.default.createServer(_this2.requestListener());
      });
    }
  }, {
    key: 'start',
    value: function start(port) {
      var _this3 = this;

      return this.createServer().then(function (server) {
        return new Promise(function (resolve, reject) {
          _this3.server = server;
          server.on('error', reject);
          server.listen(port, function () {
            return resolve(server);
          });
          debug('server started - port: %s', port);
        });
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (_this4.server) {
          _this4.server.close(function (error) {
            delete _this4.server;
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        } else {
          reject(new Error('SlackEventAdapter cannot stop when it did not start a server'));
        }
      });
    }
  }, {
    key: 'expressMiddleware',
    value: function expressMiddleware() {
      var middlewareOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var requestListener = this.requestListener(middlewareOptions);
      return function (req, res, next) {
        // If parser is being used, we can't verify request signature
        if (req.body) {
          var error = new Error('Parsing request body prohibits request signature verification');
          error.code = errorCodes.BODY_PARSER_NOT_PERMITTED;
          next(error);
          return;
        }
        requestListener(req, res);
      };
    }
  }, {
    key: 'requestListener',
    value: function requestListener() {
      var middlewareOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return (0, _httpHandler.createHTTPHandler)(this, middlewareOptions);
    }
  }]);

  return SlackEventAdapter;
}(_events2.default);

/**
 * @alias module:adapter
 */


exports.default = SlackEventAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiZXJyb3JDb2RlcyIsIkJPRFlfUEFSU0VSX05PVF9QRVJNSVRURUQiLCJTbGFja0V2ZW50QWRhcHRlciIsInNpZ25pbmdTZWNyZXQiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiaW5jbHVkZUJvZHkiLCJpbmNsdWRlSGVhZGVycyIsIndhaXRGb3JSZXNwb25zZSIsInBhdGgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJodHRwIiwiY3JlYXRlU2VydmVyIiwicmVxdWVzdExpc3RlbmVyIiwicG9ydCIsInJlamVjdCIsInNlcnZlciIsIm9uIiwibGlzdGVuIiwiY2xvc2UiLCJlcnJvciIsIkVycm9yIiwibWlkZGxld2FyZU9wdGlvbnMiLCJyZXEiLCJyZXMiLCJuZXh0IiwiYm9keSIsImNvZGUiLCJFdmVudEVtaXR0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxRQUFRLHFCQUFhLDJCQUFiLENBQWQ7O0FBRU8sSUFBTUMsa0NBQWE7QUFDeEJDLDZCQUEyQjtBQURILENBQW5COztJQUlNQyxpQixXQUFBQSxpQjs7O0FBQ1gsNkJBQVlDLGFBQVosRUFBeUM7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3ZDLFFBQUksQ0FBQyxzQkFBU0QsYUFBVCxDQUFMLEVBQThCO0FBQzVCLFlBQU0sSUFBSUUsU0FBSixDQUFjLDBDQUFkLENBQU47QUFDRDs7QUFIc0M7O0FBT3ZDLFVBQUtGLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsVUFBS0csV0FBTCxHQUFtQixDQUFDLENBQUNGLFFBQVFFLFdBQVYsSUFBeUIsS0FBNUM7QUFDQSxVQUFLQyxjQUFMLEdBQXNCLENBQUMsQ0FBQ0gsUUFBUUcsY0FBVixJQUE0QixLQUFsRDtBQUNBLFVBQUtDLGVBQUwsR0FBdUIsQ0FBQyxDQUFDSixRQUFRSSxlQUFWLElBQTZCLEtBQXBEOztBQUVBVCxVQUFNLG9DQUFOLEVBQTRDO0FBQzFDTyxtQkFBYSxNQUFLQSxXQUR3QjtBQUUxQ0Msc0JBQWdCLE1BQUtBLGNBRnFCO0FBRzFDQyx1QkFBaUIsTUFBS0E7QUFIb0IsS0FBNUM7QUFadUM7QUFpQnhDOztBQUVEOzs7OzttQ0FDcUM7QUFBQTs7QUFBQSxVQUF4QkMsSUFBd0IsdUVBQWpCLGVBQWlCOztBQUNuQztBQUNBLGFBQU9DLFFBQVFDLE9BQVIsR0FBa0JDLElBQWxCLENBQXVCLFlBQU07QUFDbENiLGNBQU0sMkJBQU4sRUFBbUNVLElBQW5DOztBQUVBLGVBQU9JLGVBQUtDLFlBQUwsQ0FBa0IsT0FBS0MsZUFBTCxFQUFsQixDQUFQO0FBQ0QsT0FKTSxDQUFQO0FBS0Q7OzswQkFFS0MsSSxFQUFNO0FBQUE7O0FBQ1YsYUFBTyxLQUFLRixZQUFMLEdBQ0pGLElBREksQ0FDQztBQUFBLGVBQVUsSUFBSUYsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVU0sTUFBVixFQUFxQjtBQUMvQyxpQkFBS0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0FBLGlCQUFPQyxFQUFQLENBQVUsT0FBVixFQUFtQkYsTUFBbkI7QUFDQUMsaUJBQU9FLE1BQVAsQ0FBY0osSUFBZCxFQUFvQjtBQUFBLG1CQUFNTCxRQUFRTyxNQUFSLENBQU47QUFBQSxXQUFwQjtBQUNBbkIsZ0JBQU0sMkJBQU4sRUFBbUNpQixJQUFuQztBQUNELFNBTGUsQ0FBVjtBQUFBLE9BREQsQ0FBUDtBQU9EOzs7MkJBRU07QUFBQTs7QUFDTCxhQUFPLElBQUlOLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVNLE1BQVYsRUFBcUI7QUFDdEMsWUFBSSxPQUFLQyxNQUFULEVBQWlCO0FBQ2YsaUJBQUtBLE1BQUwsQ0FBWUcsS0FBWixDQUFrQixVQUFDQyxLQUFELEVBQVc7QUFDM0IsbUJBQU8sT0FBS0osTUFBWjtBQUNBLGdCQUFJSSxLQUFKLEVBQVc7QUFDVEwscUJBQU9LLEtBQVA7QUFDRCxhQUZELE1BRU87QUFDTFg7QUFDRDtBQUNGLFdBUEQ7QUFRRCxTQVRELE1BU087QUFDTE0saUJBQU8sSUFBSU0sS0FBSixDQUFVLDhEQUFWLENBQVA7QUFDRDtBQUNGLE9BYk0sQ0FBUDtBQWNEOzs7d0NBRXlDO0FBQUEsVUFBeEJDLGlCQUF3Qix1RUFBSixFQUFJOztBQUN4QyxVQUFNVCxrQkFBa0IsS0FBS0EsZUFBTCxDQUFxQlMsaUJBQXJCLENBQXhCO0FBQ0EsYUFBTyxVQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBV0MsSUFBWCxFQUFvQjtBQUN6QjtBQUNBLFlBQUlGLElBQUlHLElBQVIsRUFBYztBQUNaLGNBQU1OLFFBQVEsSUFBSUMsS0FBSixDQUFVLCtEQUFWLENBQWQ7QUFDQUQsZ0JBQU1PLElBQU4sR0FBYTdCLFdBQVdDLHlCQUF4QjtBQUNBMEIsZUFBS0wsS0FBTDtBQUNBO0FBQ0Q7QUFDRFAsd0JBQWdCVSxHQUFoQixFQUFxQkMsR0FBckI7QUFDRCxPQVREO0FBVUQ7OztzQ0FFdUM7QUFBQSxVQUF4QkYsaUJBQXdCLHVFQUFKLEVBQUk7O0FBQ3RDLGFBQU8sb0NBQWtCLElBQWxCLEVBQXdCQSxpQkFBeEIsQ0FBUDtBQUNEOzs7O0VBekVvQ00sZ0I7O0FBNEV2Qzs7Ozs7a0JBR2U1QixpQiIsImZpbGUiOiJhZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoLmlzc3RyaW5nJztcbmltcG9ydCBkZWJ1Z0ZhY3RvcnkgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgY3JlYXRlSFRUUEhhbmRsZXIgfSBmcm9tICcuL2h0dHAtaGFuZGxlcic7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdAc2xhY2svZXZlbnRzLWFwaTphZGFwdGVyJyk7XG5cbmV4cG9ydCBjb25zdCBlcnJvckNvZGVzID0ge1xuICBCT0RZX1BBUlNFUl9OT1RfUEVSTUlUVEVEOiAnU0xBQ0tBREFQVEVSX0JPRFlfUEFSU0VSX05PVF9QRVJNSVRURURfRkFJTFVSRScsXG59O1xuXG5leHBvcnQgY2xhc3MgU2xhY2tFdmVudEFkYXB0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzaWduaW5nU2VjcmV0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzU3RyaW5nKHNpZ25pbmdTZWNyZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTbGFja0V2ZW50QWRhcHRlciBuZWVkcyBhIHNpZ25pbmcgc2VjcmV0Jyk7XG4gICAgfVxuXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc2lnbmluZ1NlY3JldCA9IHNpZ25pbmdTZWNyZXQ7XG4gICAgdGhpcy5pbmNsdWRlQm9keSA9ICEhb3B0aW9ucy5pbmNsdWRlQm9keSB8fCBmYWxzZTtcbiAgICB0aGlzLmluY2x1ZGVIZWFkZXJzID0gISFvcHRpb25zLmluY2x1ZGVIZWFkZXJzIHx8IGZhbHNlO1xuICAgIHRoaXMud2FpdEZvclJlc3BvbnNlID0gISFvcHRpb25zLndhaXRGb3JSZXNwb25zZSB8fCBmYWxzZTtcblxuICAgIGRlYnVnKCdhZGFwdGVyIGluc3RhbnRpYXRlZCAtIG9wdGlvbnM6ICVvJywge1xuICAgICAgaW5jbHVkZUJvZHk6IHRoaXMuaW5jbHVkZUJvZHksXG4gICAgICBpbmNsdWRlSGVhZGVyczogdGhpcy5pbmNsdWRlSGVhZGVycyxcbiAgICAgIHdhaXRGb3JSZXNwb25zZTogdGhpcy53YWl0Rm9yUmVzcG9uc2UsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiBvcHRpb25zIChsaWtlIGh0dHBzKVxuICBjcmVhdGVTZXJ2ZXIocGF0aCA9ICcvc2xhY2svZXZlbnRzJykge1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhIHNob3J0Y29taW5nIG9mIHRoZSBTeXN0ZW0uaW1wb3J0KCkgdHJhbmZvcm1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBkZWJ1Zygnc2VydmVyIGNyZWF0ZWQgLSBwYXRoOiAlcycsIHBhdGgpO1xuXG4gICAgICByZXR1cm4gaHR0cC5jcmVhdGVTZXJ2ZXIodGhpcy5yZXF1ZXN0TGlzdGVuZXIoKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydChwb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2VydmVyKClcbiAgICAgIC50aGVuKHNlcnZlciA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICBzZXJ2ZXIub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgc2VydmVyLmxpc3Rlbihwb3J0LCAoKSA9PiByZXNvbHZlKHNlcnZlcikpO1xuICAgICAgICBkZWJ1Zygnc2VydmVyIHN0YXJ0ZWQgLSBwb3J0OiAlcycsIHBvcnQpO1xuICAgICAgfSkpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyLmNsb3NlKChlcnJvcikgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlcnZlcjtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU2xhY2tFdmVudEFkYXB0ZXIgY2Fubm90IHN0b3Agd2hlbiBpdCBkaWQgbm90IHN0YXJ0IGEgc2VydmVyJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZXhwcmVzc01pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3RMaXN0ZW5lciA9IHRoaXMucmVxdWVzdExpc3RlbmVyKG1pZGRsZXdhcmVPcHRpb25zKTtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAvLyBJZiBwYXJzZXIgaXMgYmVpbmcgdXNlZCwgd2UgY2FuJ3QgdmVyaWZ5IHJlcXVlc3Qgc2lnbmF0dXJlXG4gICAgICBpZiAocmVxLmJvZHkpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1BhcnNpbmcgcmVxdWVzdCBib2R5IHByb2hpYml0cyByZXF1ZXN0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb24nKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZXMuQk9EWV9QQVJTRVJfTk9UX1BFUk1JVFRFRDtcbiAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3RMaXN0ZW5lcihyZXEsIHJlcyk7XG4gICAgfTtcbiAgfVxuXG4gIHJlcXVlc3RMaXN0ZW5lcihtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUVFBIYW5kbGVyKHRoaXMsIG1pZGRsZXdhcmVPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6YWRhcHRlclxuICovXG5leHBvcnQgZGVmYXVsdCBTbGFja0V2ZW50QWRhcHRlcjtcbiJdfQ==
//# sourceMappingURL=adapter.js.map